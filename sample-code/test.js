reverseTransaction1({
    processId: "434345", // Frequency ID
    transactions: [
        {
            orderId: "24345", // Unique ID generated by Binance
            symbol: "BTCUSDT",
            side: "BUY",
            price: "32435", // Price at which the order is to be placed (Not useful for report only required for coding purposes)
            cummulativeQuoteQty: "10", // Quantity of ticker 2
            executedQty: "1", // Quantity of ticker 1
            executedPrice: "56577", // Average price of the fill orders
            precision: 5, // The max precision accepted for a coin pair
            attempts: 3 // No of attempts we make to the API call to execute the order
        },
        {
            orderId: null,
            symbol: "ETHBTC",
            side: "BUY",
            price: null,
            cummulativeQuoteQty: null,
            executedQty: null,
            executedPrice: null,
            precision: 4,
            attempts: 3
        },
        {
            orderId: null,
            symbol: "BNBETH",
            side: "BUY",
            price: null,
            cummulativeQuoteQty: null,
            executedQty: null,
            executedPrice: null,
            precision: 3,
            attempts: null
        },
        {
            orderId: null,
            symbol: "BNBUSDT",
            side: "SELL",
            price: null,
            executedQty: null,
            executedPrice: null,
            precision: 3,
            attempts: 1
        }
    ]
})

if (side === "BUY") {
    if (type === "MARKET") {
        quantity = getPrecision(quantity, precision);
        params["quoteOrderQty"] = quantity;
    } else {
        // Only while buying the asset in limit we would need to reduce transaction fee and find the quantity of the buying asset
        quantity = getCapitalAfterFees(quantity);
        quantity = getPrecision(quantity, precision);
        params["quantity"] = quantity;
        console.log("asd2", side, quantity);
        // Add extra required paramters for Limit order
        params["price"] = price;
        params["timeInForce"] = timeInForce;
    }
} else { // SELL
    if (type === "MARKET") {
        quantity = getPrecision(quantity, precision);
        params["quoteOrderQty"] = quantity;
    } else {

    }
}

quantity = getPrecision(quantity, precision);
params["quantity"] = quantity;


// Function 1: Limit order using $10 to buy asset1
async function function1(condition, isMarketOrder = false, amount = 10) {
    if (condition === 1) {
        try {
            await fetchPrices(["BTCUSDT", "ETHUSDT", "BNBUSDT", "XRPUSDT"]);
            console.log('Function 1 prices:', globalPrices);

            let orderStatus;
            if (isMarketOrder) {
                orderStatus = await executeMarketOrder(globalPrices.asset1, amount);
            } else {
                orderStatus = await executeLimitOrder(globalPrices.asset1, amount);
            }

            if (orderStatus.status === 'full') {
                console.log('Function 1 fully executed.');

                // Wait for 1 second
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Fetch and update new prices
                await fetchPrices();
                console.log('Updated global prices:', globalPrices);

                // Call function2 with the executed coins
                await function2(orderStatus.executedUnits);
            } else if (orderStatus.status === 'partial') {
                console.log('Function 1 partially executed.');

                // Run function2 with the executed coins
                function2(orderStatus.executedUnits);

                // Re-run function1 as a market order with the remaining amount in parallel
                function1(condition, true, orderStatus.remainingAmount);
            } else {
                console.log('Function 1 execution failed.');
            }
        } catch (error) {
            console.error('Error in function 1:', error);
        }
    } else {
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// Function 2: Limit order using remaining units to buy another asset
async function function2(remainingUnits) {
    try {
        let orderResult = await executeLimitOrder(globalPrices.asset2, remainingUnits); // Using global asset2 price
        if (orderResult.status === 'none') {
            console.log('Function 2: Nothing executed, cancelling and reversing order.');
            await reverseTrade();
        } else if (orderResult.status === 'partial') {
            console.log(`Function 2: Partially executed. ${orderResult.executedUnits} units for asset2.`);
            await function3(orderResult.remainingUnits);
        } else {
            console.log(`Function 2: Fully executed. ${orderResult.executedUnits} units for asset2.`);
            await function3(0);
        }
    } catch (error) {
        console.error('Error in function 2:', error);
    }
}

async function reverseTrade() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log('Trade reversed.');
            resolve();
        }, 1000);
    });
}

// Function 3: Continue with API execution
async function function3(remainingUnits) {
    console.log('Executing function 3 with global prices:', globalPrices);
    if (remainingUnits > 0) {
        console.log(`Remaining units to execute: ${remainingUnits}`);
        await function4(remainingUnits);
    } else {
        await function4(0);
    }
}

// Function 4: Final market order
async function function4(remainingUnits) {
    console.log('Executing final market order in function 4 with global prices:', globalPrices);
    if (remainingUnits > 0) {
        await executeMarketOrder(globalPrices.asset1, remainingUnits);
    }
}
